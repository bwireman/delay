{
  "version": 3,
  "sources": ["../build/dev/javascript/prelude.mjs", "../build/dev/javascript/gleam_stdlib/gleam/result.mjs", "../build/dev/javascript/gleam_stdlib/dict.mjs", "../build/dev/javascript/gleam_stdlib/gleam/list.mjs", "../build/dev/javascript/delay/delay.mjs"],
  "sourcesContent": ["// Values marked with @internal are not part of the public API and may change\n// without notice.\n\nexport class CustomType {\n  withFields(fields) {\n    let properties = Object.keys(this).map((label) =>\n      label in fields ? fields[label] : this[label],\n    );\n    return new this.constructor(...properties);\n  }\n}\n\nexport class List {\n  static fromArray(array, tail) {\n    let t = tail || new Empty();\n    return array.reduceRight((xs, x) => new NonEmpty(x, xs), t);\n  }\n\n  [Symbol.iterator]() {\n    return new ListIterator(this);\n  }\n\n  toArray() {\n    return [...this];\n  }\n\n  // @internal\n  atLeastLength(desired) {\n    for (let _ of this) {\n      if (desired <= 0) return true;\n      desired--;\n    }\n    return desired <= 0;\n  }\n\n  // @internal\n  hasLength(desired) {\n    for (let _ of this) {\n      if (desired <= 0) return false;\n      desired--;\n    }\n    return desired === 0;\n  }\n\n  countLength() {\n    let length = 0;\n    for (let _ of this) length++;\n    return length;\n  }\n}\n\nexport function toList(elements, tail) {\n  return List.fromArray(elements, tail);\n}\n\n// @internal\nclass ListIterator {\n  #current;\n\n  constructor(current) {\n    this.#current = current;\n  }\n\n  next() {\n    if (this.#current instanceof Empty) {\n      return { done: true };\n    } else {\n      let { head, tail } = this.#current;\n      this.#current = tail;\n      return { value: head, done: false };\n    }\n  }\n}\n\nexport class Empty extends List {}\n\nexport class NonEmpty extends List {\n  constructor(head, tail) {\n    super();\n    this.head = head;\n    this.tail = tail;\n  }\n}\n\nexport class BitArray {\n  constructor(buffer) {\n    if (!(buffer instanceof Uint8Array)) {\n      throw \"BitArray can only be constructed from a Uint8Array\";\n    }\n    this.buffer = buffer;\n  }\n\n  // @internal\n  get length() {\n    return this.buffer.length;\n  }\n\n  // @internal\n  byteAt(index) {\n    return this.buffer[index];\n  }\n\n  // @internal\n  floatAt(index) {\n    return byteArrayToFloat(this.buffer.slice(index, index + 8));\n  }\n\n  // @internal\n  intFromSlice(start, end) {\n    return byteArrayToInt(this.buffer.slice(start, end));\n  }\n\n  // @internal\n  binaryFromSlice(start, end) {\n    return new BitArray(this.buffer.slice(start, end));\n  }\n\n  // @internal\n  sliceAfter(index) {\n    return new BitArray(this.buffer.slice(index));\n  }\n}\n\nexport class UtfCodepoint {\n  constructor(value) {\n    this.value = value;\n  }\n}\n\n// @internal\nexport function toBitArray(segments) {\n  let size = (segment) =>\n    segment instanceof Uint8Array ? segment.byteLength : 1;\n  let bytes = segments.reduce((acc, segment) => acc + size(segment), 0);\n  let view = new DataView(new ArrayBuffer(bytes));\n  let cursor = 0;\n  for (let segment of segments) {\n    if (segment instanceof Uint8Array) {\n      new Uint8Array(view.buffer).set(segment, cursor);\n      cursor += segment.byteLength;\n    } else {\n      view.setInt8(cursor, segment);\n      cursor++;\n    }\n  }\n  return new BitArray(new Uint8Array(view.buffer));\n}\n\n// @internal\n// Derived from this answer https://stackoverflow.com/questions/8482309/converting-javascript-integer-to-byte-array-and-back\nexport function sizedInt(int, size) {\n  let value = int;\n  if (size < 0) {\n    return new Uint8Array();\n  }\n  if (size % 8 != 0) {\n    const msg = `Bit arrays must be byte aligned on JavaScript, got size of ${size} bits`;\n    throw new globalThis.Error(msg);\n  }\n  const byteArray = new Uint8Array(size / 8);\n\n  for (let index = 0; index < byteArray.length; index++) {\n    const byte = value & 0xff;\n    byteArray[index] = byte;\n    value = (value - byte) / 256;\n  }\n  return byteArray.reverse();\n}\n\n// @internal\nexport function byteArrayToInt(byteArray) {\n  byteArray = byteArray.reverse();\n  let value = 0;\n  for (let i = byteArray.length - 1; i >= 0; i--) {\n    value = value * 256 + byteArray[i];\n  }\n  return value;\n}\n\n// @internal\nexport function byteArrayToFloat(byteArray) {\n  return new Float64Array(byteArray.reverse().buffer)[0];\n}\n\n// @internal\nexport function stringBits(string) {\n  return new TextEncoder().encode(string);\n}\n\n// @internal\nexport function codepointBits(codepoint) {\n  return stringBits(String.fromCodePoint(codepoint.value));\n}\n\n// @internal\nexport function float64Bits(float) {\n  return new Uint8Array(Float64Array.from([float]).buffer).reverse();\n}\n\nexport class Result extends CustomType {\n  // @internal\n  static isResult(data) {\n    return data instanceof Result;\n  }\n}\n\nexport class Ok extends Result {\n  constructor(value) {\n    super();\n    this[0] = value;\n  }\n\n  // @internal\n  isOk() {\n    return true;\n  }\n}\n\nexport class Error extends Result {\n  constructor(detail) {\n    super();\n    this[0] = detail;\n  }\n\n  // @internal\n  isOk() {\n    return false;\n  }\n}\n\nexport function isEqual(x, y) {\n  let values = [x, y];\n\n  while (values.length) {\n    let a = values.pop();\n    let b = values.pop();\n    if (a === b) continue;\n\n    if (!isObject(a) || !isObject(b)) return false;\n    let unequal =\n      !structurallyCompatibleObjects(a, b) ||\n      unequalDates(a, b) ||\n      unequalBuffers(a, b) ||\n      unequalArrays(a, b) ||\n      unequalMaps(a, b) ||\n      unequalSets(a, b) ||\n      unequalRegExps(a, b);\n    if (unequal) return false;\n\n    const proto = Object.getPrototypeOf(a);\n    if (proto !== null && typeof proto.equals === \"function\") {\n      try {\n        if (a.equals(b)) continue;\n        else return false;\n      } catch {}\n    }\n\n    let [keys, get] = getters(a);\n    for (let k of keys(a)) {\n      values.push(get(a, k), get(b, k));\n    }\n  }\n\n  return true;\n}\n\nfunction getters(object) {\n  if (object instanceof Map) {\n    return [(x) => x.keys(), (x, y) => x.get(y)];\n  } else {\n    let extra = object instanceof globalThis.Error ? [\"message\"] : [];\n    return [(x) => [...extra, ...Object.keys(x)], (x, y) => x[y]];\n  }\n}\n\nfunction unequalDates(a, b) {\n  return a instanceof Date && (a > b || a < b);\n}\n\nfunction unequalBuffers(a, b) {\n  return (\n    a.buffer instanceof ArrayBuffer &&\n    a.BYTES_PER_ELEMENT &&\n    !(a.byteLength === b.byteLength && a.every((n, i) => n === b[i]))\n  );\n}\n\nfunction unequalArrays(a, b) {\n  return Array.isArray(a) && a.length !== b.length;\n}\n\nfunction unequalMaps(a, b) {\n  return a instanceof Map && a.size !== b.size;\n}\n\nfunction unequalSets(a, b) {\n  return (\n    a instanceof Set && (a.size != b.size || [...a].some((e) => !b.has(e)))\n  );\n}\n\nfunction unequalRegExps(a, b) {\n  return a instanceof RegExp && (a.source !== b.source || a.flags !== b.flags);\n}\n\nfunction isObject(a) {\n  return typeof a === \"object\" && a !== null;\n}\n\nfunction structurallyCompatibleObjects(a, b) {\n  if (typeof a !== \"object\" && typeof b !== \"object\" && (!a || !b))\n    return false;\n\n  let nonstructural = [Promise, WeakSet, WeakMap, Function];\n  if (nonstructural.some((c) => a instanceof c)) return false;\n\n  return a.constructor === b.constructor;\n}\n\n// @internal\nexport function remainderInt(a, b) {\n  if (b === 0) {\n    return 0;\n  } else {\n    return a % b;\n  }\n}\n\n// @internal\nexport function divideInt(a, b) {\n  return Math.trunc(divideFloat(a, b));\n}\n\n// @internal\nexport function divideFloat(a, b) {\n  if (b === 0) {\n    return 0;\n  } else {\n    return a / b;\n  }\n}\n\n// @internal\nexport function makeError(variant, module, line, fn, message, extra) {\n  let error = new globalThis.Error(message);\n  error.gleam_error = variant;\n  error.module = module;\n  error.line = line;\n  error.fn = fn;\n  for (let k in extra) error[k] = extra[k];\n  return error;\n}\n", "import { Ok, Error, toList } from \"../gleam.mjs\";\nimport * as $list from \"../gleam/list.mjs\";\n\nexport function is_ok(result) {\n  if (!result.isOk()) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function is_error(result) {\n  if (result.isOk()) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function map(result, fun) {\n  if (result.isOk()) {\n    let x = result[0];\n    return new Ok(fun(x));\n  } else {\n    let e = result[0];\n    return new Error(e);\n  }\n}\n\nexport function map_error(result, fun) {\n  if (result.isOk()) {\n    let x = result[0];\n    return new Ok(x);\n  } else {\n    let error = result[0];\n    return new Error(fun(error));\n  }\n}\n\nexport function flatten(result) {\n  if (result.isOk()) {\n    let x = result[0];\n    return x;\n  } else {\n    let error = result[0];\n    return new Error(error);\n  }\n}\n\nexport function try$(result, fun) {\n  if (result.isOk()) {\n    let x = result[0];\n    return fun(x);\n  } else {\n    let e = result[0];\n    return new Error(e);\n  }\n}\n\nexport function then$(result, fun) {\n  return try$(result, fun);\n}\n\nexport function unwrap(result, default$) {\n  if (result.isOk()) {\n    let v = result[0];\n    return v;\n  } else {\n    return default$;\n  }\n}\n\nexport function lazy_unwrap(result, default$) {\n  if (result.isOk()) {\n    let v = result[0];\n    return v;\n  } else {\n    return default$();\n  }\n}\n\nexport function unwrap_error(result, default$) {\n  if (result.isOk()) {\n    return default$;\n  } else {\n    let e = result[0];\n    return e;\n  }\n}\n\nexport function unwrap_both(result) {\n  if (result.isOk()) {\n    let a = result[0];\n    return a;\n  } else {\n    let a = result[0];\n    return a;\n  }\n}\n\nexport function nil_error(result) {\n  return map_error(result, (_) => { return undefined; });\n}\n\nexport function or(first, second) {\n  if (first.isOk()) {\n    return first;\n  } else {\n    return second;\n  }\n}\n\nexport function lazy_or(first, second) {\n  if (first.isOk()) {\n    return first;\n  } else {\n    return second();\n  }\n}\n\nexport function all(results) {\n  return $list.try_map(results, (x) => { return x; });\n}\n\nfunction do_partition(loop$results, loop$oks, loop$errors) {\n  while (true) {\n    let results = loop$results;\n    let oks = loop$oks;\n    let errors = loop$errors;\n    if (results.hasLength(0)) {\n      return [oks, errors];\n    } else if (results.atLeastLength(1) && results.head.isOk()) {\n      let a = results.head[0];\n      let rest = results.tail;\n      loop$results = rest;\n      loop$oks = toList([a], oks);\n      loop$errors = errors;\n    } else {\n      let e = results.head[0];\n      let rest = results.tail;\n      loop$results = rest;\n      loop$oks = oks;\n      loop$errors = toList([e], errors);\n    }\n  }\n}\n\nexport function partition(results) {\n  return do_partition(results, toList([]), toList([]));\n}\n\nexport function replace(result, value) {\n  if (result.isOk()) {\n    return new Ok(value);\n  } else {\n    let error = result[0];\n    return new Error(error);\n  }\n}\n\nexport function replace_error(result, error) {\n  if (result.isOk()) {\n    let x = result[0];\n    return new Ok(x);\n  } else {\n    return new Error(error);\n  }\n}\n\nexport function values(results) {\n  return $list.filter_map(results, (r) => { return r; });\n}\n\nexport function try_recover(result, fun) {\n  if (result.isOk()) {\n    let value = result[0];\n    return new Ok(value);\n  } else {\n    let error = result[0];\n    return fun(error);\n  }\n}\n", "/**\n * This file uses jsdoc to annotate types.\n * These types can be checked using the typescript compiler with \"checkjs\" option.\n */\n\nimport { isEqual } from \"./gleam.mjs\";\n\nconst referenceMap = new WeakMap();\nconst tempDataView = new DataView(new ArrayBuffer(8));\nlet referenceUID = 0;\n/**\n * hash the object by reference using a weak map and incrementing uid\n * @param {any} o\n * @returns {number}\n */\nfunction hashByReference(o) {\n  const known = referenceMap.get(o);\n  if (known !== undefined) {\n    return known;\n  }\n  const hash = referenceUID++;\n  if (referenceUID === 0x7fffffff) {\n    referenceUID = 0;\n  }\n  referenceMap.set(o, hash);\n  return hash;\n}\n/**\n * merge two hashes in an order sensitive way\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction hashMerge(a, b) {\n  return (a ^ (b + 0x9e3779b9 + (a << 6) + (a >> 2))) | 0;\n}\n/**\n * standard string hash popularised by java\n * @param {string} s\n * @returns {number}\n */\nfunction hashString(s) {\n  let hash = 0;\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    hash = (Math.imul(31, hash) + s.charCodeAt(i)) | 0;\n  }\n  return hash;\n}\n/**\n * hash a number by converting to two integers and do some jumbling\n * @param {number} n\n * @returns {number}\n */\nfunction hashNumber(n) {\n  tempDataView.setFloat64(0, n);\n  const i = tempDataView.getInt32(0);\n  const j = tempDataView.getInt32(4);\n  return Math.imul(0x45d9f3b, (i >> 16) ^ i) ^ j;\n}\n/**\n * hash a BigInt by converting it to a string and hashing that\n * @param {BigInt} n\n * @returns {number}\n */\nfunction hashBigInt(n) {\n  return hashString(n.toString());\n}\n/**\n * hash any js object\n * @param {any} o\n * @returns {number}\n */\nfunction hashObject(o) {\n  const proto = Object.getPrototypeOf(o);\n  if (proto !== null && typeof proto.hashCode === \"function\") {\n    try {\n      const code = o.hashCode(o);\n      if (typeof code === \"number\") {\n        return code;\n      }\n    } catch {}\n  }\n  if (o instanceof Promise || o instanceof WeakSet || o instanceof WeakMap) {\n    return hashByReference(o);\n  }\n  if (o instanceof Date) {\n    return hashNumber(o.getTime());\n  }\n  let h = 0;\n  if (o instanceof ArrayBuffer) {\n    o = new Uint8Array(o);\n  }\n  if (Array.isArray(o) || o instanceof Uint8Array) {\n    for (let i = 0; i < o.length; i++) {\n      h = (Math.imul(31, h) + getHash(o[i])) | 0;\n    }\n  } else if (o instanceof Set) {\n    o.forEach((v) => {\n      h = (h + getHash(v)) | 0;\n    });\n  } else if (o instanceof Map) {\n    o.forEach((v, k) => {\n      h = (h + hashMerge(getHash(v), getHash(k))) | 0;\n    });\n  } else {\n    const keys = Object.keys(o);\n    for (let i = 0; i < keys.length; i++) {\n      const k = keys[i];\n      const v = o[k];\n      h = (h + hashMerge(getHash(v), hashString(k))) | 0;\n    }\n  }\n  return h;\n}\n/**\n * hash any js value\n * @param {any} u\n * @returns {number}\n */\nexport function getHash(u) {\n  if (u === null) return 0x42108422;\n  if (u === undefined) return 0x42108423;\n  if (u === true) return 0x42108421;\n  if (u === false) return 0x42108420;\n  switch (typeof u) {\n    case \"number\":\n      return hashNumber(u);\n    case \"string\":\n      return hashString(u);\n    case \"bigint\":\n      return hashBigInt(u);\n    case \"object\":\n      return hashObject(u);\n    case \"symbol\":\n      return hashByReference(u);\n    case \"function\":\n      return hashByReference(u);\n    default:\n      return 0; // should be unreachable\n  }\n}\n/**\n * @template K,V\n * @typedef {ArrayNode<K,V> | IndexNode<K,V> | CollisionNode<K,V>} Node\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof ENTRY, k: K, v: V }} Entry\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof ARRAY_NODE, size: number, array: (undefined | Entry<K,V> | Node<K,V>)[] }} ArrayNode\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof INDEX_NODE, bitmap: number, array: (Entry<K,V> | Node<K,V>)[] }} IndexNode\n */\n/**\n * @template K,V\n * @typedef {{ type: typeof COLLISION_NODE, hash: number, array: Entry<K, V>[] }} CollisionNode\n */\n/**\n * @typedef {{ val: boolean }} Flag\n */\nconst SHIFT = 5; // number of bits you need to shift by to get the next bucket\nconst BUCKET_SIZE = Math.pow(2, SHIFT);\nconst MASK = BUCKET_SIZE - 1; // used to zero out all bits not in the bucket\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2; // when does index node grow into array node\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4; // when does array node shrink to index node\nconst ENTRY = 0;\nconst ARRAY_NODE = 1;\nconst INDEX_NODE = 2;\nconst COLLISION_NODE = 3;\n/** @type {IndexNode<any,any>} */\nconst EMPTY = {\n  type: INDEX_NODE,\n  bitmap: 0,\n  array: [],\n};\n/**\n * Mask the hash to get only the bucket corresponding to shift\n * @param {number} hash\n * @param {number} shift\n * @returns {number}\n */\nfunction mask(hash, shift) {\n  return (hash >>> shift) & MASK;\n}\n/**\n * Set only the Nth bit where N is the masked hash\n * @param {number} hash\n * @param {number} shift\n * @returns {number}\n */\nfunction bitpos(hash, shift) {\n  return 1 << mask(hash, shift);\n}\n/**\n * Count the number of 1 bits in a number\n * @param {number} x\n * @returns {number}\n */\nfunction bitcount(x) {\n  x -= (x >> 1) & 0x55555555;\n  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n  x = (x + (x >> 4)) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n/**\n * Calculate the array index of an item in a bitmap index node\n * @param {number} bitmap\n * @param {number} bit\n * @returns {number}\n */\nfunction index(bitmap, bit) {\n  return bitcount(bitmap & (bit - 1));\n}\n/**\n * Efficiently copy an array and set one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @param {T} val\n * @returns {T[]}\n */\nfunction cloneAndSet(arr, at, val) {\n  const len = arr.length;\n  const out = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    out[i] = arr[i];\n  }\n  out[at] = val;\n  return out;\n}\n/**\n * Efficiently copy an array and insert one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @param {T} val\n * @returns {T[]}\n */\nfunction spliceIn(arr, at, val) {\n  const len = arr.length;\n  const out = new Array(len + 1);\n  let i = 0;\n  let g = 0;\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n  out[g++] = val;\n  while (i < len) {\n    out[g++] = arr[i++];\n  }\n  return out;\n}\n/**\n * Efficiently copy an array and remove one value at an index\n * @template T\n * @param {T[]} arr\n * @param {number} at\n * @returns {T[]}\n */\nfunction spliceOut(arr, at) {\n  const len = arr.length;\n  const out = new Array(len - 1);\n  let i = 0;\n  let g = 0;\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n  ++i;\n  while (i < len) {\n    out[g++] = arr[i++];\n  }\n  return out;\n}\n/**\n * Create a new node containing two entries\n * @template K,V\n * @param {number} shift\n * @param {K} key1\n * @param {V} val1\n * @param {number} key2hash\n * @param {K} key2\n * @param {V} val2\n * @returns {Node<K,V>}\n */\nfunction createNode(shift, key1, val1, key2hash, key2, val2) {\n  const key1hash = getHash(key1);\n  if (key1hash === key2hash) {\n    return {\n      type: COLLISION_NODE,\n      hash: key1hash,\n      array: [\n        { type: ENTRY, k: key1, v: val1 },\n        { type: ENTRY, k: key2, v: val2 },\n      ],\n    };\n  }\n  const addedLeaf = { val: false };\n  return assoc(\n    assocIndex(EMPTY, shift, key1hash, key1, val1, addedLeaf),\n    shift,\n    key2hash,\n    key2,\n    val2,\n    addedLeaf\n  );\n}\n/**\n * @template T,K,V\n * @callback AssocFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @param {V} val\n * @param {Flag} addedLeaf\n * @returns {Node<K,V>}\n */\n/**\n * Associate a node with a new entry, creating a new node\n * @template T,K,V\n * @type {AssocFunction<Node<K,V>,K,V>}\n */\nfunction assoc(root, shift, hash, key, val, addedLeaf) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return assocArray(root, shift, hash, key, val, addedLeaf);\n    case INDEX_NODE:\n      return assocIndex(root, shift, hash, key, val, addedLeaf);\n    case COLLISION_NODE:\n      return assocCollision(root, shift, hash, key, val, addedLeaf);\n  }\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<ArrayNode<K,V>,K,V>}\n */\nfunction assocArray(root, shift, hash, key, val, addedLeaf) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  // if the corresponding index is empty set the index to a newly created node\n  if (node === undefined) {\n    addedLeaf.val = true;\n    return {\n      type: ARRAY_NODE,\n      size: root.size + 1,\n      array: cloneAndSet(root.array, idx, { type: ENTRY, k: key, v: val }),\n    };\n  }\n  if (node.type === ENTRY) {\n    // if keys are equal replace the entry\n    if (isEqual(key, node.k)) {\n      if (val === node.v) {\n        return root;\n      }\n      return {\n        type: ARRAY_NODE,\n        size: root.size,\n        array: cloneAndSet(root.array, idx, {\n          type: ENTRY,\n          k: key,\n          v: val,\n        }),\n      };\n    }\n    // otherwise upgrade the entry to a node and insert\n    addedLeaf.val = true;\n    return {\n      type: ARRAY_NODE,\n      size: root.size,\n      array: cloneAndSet(\n        root.array,\n        idx,\n        createNode(shift + SHIFT, node.k, node.v, hash, key, val)\n      ),\n    };\n  }\n  // otherwise call assoc on the child node\n  const n = assoc(node, shift + SHIFT, hash, key, val, addedLeaf);\n  // if the child node hasn't changed just return the old root\n  if (n === node) {\n    return root;\n  }\n  // otherwise set the index to the new node\n  return {\n    type: ARRAY_NODE,\n    size: root.size,\n    array: cloneAndSet(root.array, idx, n),\n  };\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<IndexNode<K,V>,K,V>}\n */\nfunction assocIndex(root, shift, hash, key, val, addedLeaf) {\n  const bit = bitpos(hash, shift);\n  const idx = index(root.bitmap, bit);\n  // if there is already a item at this hash index..\n  if ((root.bitmap & bit) !== 0) {\n    // if there is a node at the index (not an entry), call assoc on the child node\n    const node = root.array[idx];\n    if (node.type !== ENTRY) {\n      const n = assoc(node, shift + SHIFT, hash, key, val, addedLeaf);\n      if (n === node) {\n        return root;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, n),\n      };\n    }\n    // otherwise there is an entry at the index\n    // if the keys are equal replace the entry with the updated value\n    const nodeKey = node.k;\n    if (isEqual(key, nodeKey)) {\n      if (val === node.v) {\n        return root;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, {\n          type: ENTRY,\n          k: key,\n          v: val,\n        }),\n      };\n    }\n    // if the keys are not equal, replace the entry with a new child node\n    addedLeaf.val = true;\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap,\n      array: cloneAndSet(\n        root.array,\n        idx,\n        createNode(shift + SHIFT, nodeKey, node.v, hash, key, val)\n      ),\n    };\n  } else {\n    // else there is currently no item at the hash index\n    const n = root.array.length;\n    // if the number of nodes is at the maximum, expand this node into an array node\n    if (n >= MAX_INDEX_NODE) {\n      // create a 32 length array for the new array node (one for each bit in the hash)\n      const nodes = new Array(32);\n      // create and insert a node for the new entry\n      const jdx = mask(hash, shift);\n      nodes[jdx] = assocIndex(EMPTY, shift + SHIFT, hash, key, val, addedLeaf);\n      let j = 0;\n      let bitmap = root.bitmap;\n      // place each item in the index node into the correct spot in the array node\n      // loop through all 32 bits / array positions\n      for (let i = 0; i < 32; i++) {\n        if ((bitmap & 1) !== 0) {\n          const node = root.array[j++];\n          nodes[i] = node;\n        }\n        // shift the bitmap to process the next bit\n        bitmap = bitmap >>> 1;\n      }\n      return {\n        type: ARRAY_NODE,\n        size: n + 1,\n        array: nodes,\n      };\n    } else {\n      // else there is still space in this index node\n      // simply insert a new entry at the hash index\n      const newArray = spliceIn(root.array, idx, {\n        type: ENTRY,\n        k: key,\n        v: val,\n      });\n      addedLeaf.val = true;\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap | bit,\n        array: newArray,\n      };\n    }\n  }\n}\n/**\n * @template T,K,V\n * @type {AssocFunction<CollisionNode<K,V>,K,V>}\n */\nfunction assocCollision(root, shift, hash, key, val, addedLeaf) {\n  // if there is a hash collision\n  if (hash === root.hash) {\n    const idx = collisionIndexOf(root, key);\n    // if this key already exists replace the entry with the new value\n    if (idx !== -1) {\n      const entry = root.array[idx];\n      if (entry.v === val) {\n        return root;\n      }\n      return {\n        type: COLLISION_NODE,\n        hash: hash,\n        array: cloneAndSet(root.array, idx, { type: ENTRY, k: key, v: val }),\n      };\n    }\n    // otherwise insert the entry at the end of the array\n    const size = root.array.length;\n    addedLeaf.val = true;\n    return {\n      type: COLLISION_NODE,\n      hash: hash,\n      array: cloneAndSet(root.array, size, { type: ENTRY, k: key, v: val }),\n    };\n  }\n  // if there is no hash collision, upgrade to an index node\n  return assoc(\n    {\n      type: INDEX_NODE,\n      bitmap: bitpos(root.hash, shift),\n      array: [root],\n    },\n    shift,\n    hash,\n    key,\n    val,\n    addedLeaf\n  );\n}\n/**\n * Find the index of a key in the collision node's array\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {number}\n */\nfunction collisionIndexOf(root, key) {\n  const size = root.array.length;\n  for (let i = 0; i < size; i++) {\n    if (isEqual(key, root.array[i].k)) {\n      return i;\n    }\n  }\n  return -1;\n}\n/**\n * @template T,K,V\n * @callback FindFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @returns {undefined | Entry<K,V>}\n */\n/**\n * Return the found entry or undefined if not present in the root\n * @template K,V\n * @type {FindFunction<Node<K,V>,K,V>}\n */\nfunction find(root, shift, hash, key) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return findArray(root, shift, hash, key);\n    case INDEX_NODE:\n      return findIndex(root, shift, hash, key);\n    case COLLISION_NODE:\n      return findCollision(root, key);\n  }\n}\n/**\n * @template K,V\n * @type {FindFunction<ArrayNode<K,V>,K,V>}\n */\nfunction findArray(root, shift, hash, key) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  if (node === undefined) {\n    return undefined;\n  }\n  if (node.type !== ENTRY) {\n    return find(node, shift + SHIFT, hash, key);\n  }\n  if (isEqual(key, node.k)) {\n    return node;\n  }\n  return undefined;\n}\n/**\n * @template K,V\n * @type {FindFunction<IndexNode<K,V>,K,V>}\n */\nfunction findIndex(root, shift, hash, key) {\n  const bit = bitpos(hash, shift);\n  if ((root.bitmap & bit) === 0) {\n    return undefined;\n  }\n  const idx = index(root.bitmap, bit);\n  const node = root.array[idx];\n  if (node.type !== ENTRY) {\n    return find(node, shift + SHIFT, hash, key);\n  }\n  if (isEqual(key, node.k)) {\n    return node;\n  }\n  return undefined;\n}\n/**\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {undefined | Entry<K,V>}\n */\nfunction findCollision(root, key) {\n  const idx = collisionIndexOf(root, key);\n  if (idx < 0) {\n    return undefined;\n  }\n  return root.array[idx];\n}\n/**\n * @template T,K,V\n * @callback WithoutFunction\n * @param {T} root\n * @param {number} shift\n * @param {number} hash\n * @param {K} key\n * @returns {undefined | Node<K,V>}\n */\n/**\n * Remove an entry from the root, returning the updated root.\n * Returns undefined if the node should be removed from the parent.\n * @template K,V\n * @type {WithoutFunction<Node<K,V>,K,V>}\n * */\nfunction without(root, shift, hash, key) {\n  switch (root.type) {\n    case ARRAY_NODE:\n      return withoutArray(root, shift, hash, key);\n    case INDEX_NODE:\n      return withoutIndex(root, shift, hash, key);\n    case COLLISION_NODE:\n      return withoutCollision(root, key);\n  }\n}\n/**\n * @template K,V\n * @type {WithoutFunction<ArrayNode<K,V>,K,V>}\n */\nfunction withoutArray(root, shift, hash, key) {\n  const idx = mask(hash, shift);\n  const node = root.array[idx];\n  if (node === undefined) {\n    return root; // already empty\n  }\n  let n = undefined;\n  // if node is an entry and the keys are not equal there is nothing to remove\n  // if node is not an entry do a recursive call\n  if (node.type === ENTRY) {\n    if (!isEqual(node.k, key)) {\n      return root; // no changes\n    }\n  } else {\n    n = without(node, shift + SHIFT, hash, key);\n    if (n === node) {\n      return root; // no changes\n    }\n  }\n  // if the recursive call returned undefined the node should be removed\n  if (n === undefined) {\n    // if the number of child nodes is at the minimum, pack into an index node\n    if (root.size <= MIN_ARRAY_NODE) {\n      const arr = root.array;\n      const out = new Array(root.size - 1);\n      let i = 0;\n      let j = 0;\n      let bitmap = 0;\n      while (i < idx) {\n        const nv = arr[i];\n        if (nv !== undefined) {\n          out[j] = nv;\n          bitmap |= 1 << i;\n          ++j;\n        }\n        ++i;\n      }\n      ++i; // skip copying the removed node\n      while (i < arr.length) {\n        const nv = arr[i];\n        if (nv !== undefined) {\n          out[j] = nv;\n          bitmap |= 1 << i;\n          ++j;\n        }\n        ++i;\n      }\n      return {\n        type: INDEX_NODE,\n        bitmap: bitmap,\n        array: out,\n      };\n    }\n    return {\n      type: ARRAY_NODE,\n      size: root.size - 1,\n      array: cloneAndSet(root.array, idx, n),\n    };\n  }\n  return {\n    type: ARRAY_NODE,\n    size: root.size,\n    array: cloneAndSet(root.array, idx, n),\n  };\n}\n/**\n * @template K,V\n * @type {WithoutFunction<IndexNode<K,V>,K,V>}\n */\nfunction withoutIndex(root, shift, hash, key) {\n  const bit = bitpos(hash, shift);\n  if ((root.bitmap & bit) === 0) {\n    return root; // already empty\n  }\n  const idx = index(root.bitmap, bit);\n  const node = root.array[idx];\n  // if the item is not an entry\n  if (node.type !== ENTRY) {\n    const n = without(node, shift + SHIFT, hash, key);\n    if (n === node) {\n      return root; // no changes\n    }\n    // if not undefined, the child node still has items, so update it\n    if (n !== undefined) {\n      return {\n        type: INDEX_NODE,\n        bitmap: root.bitmap,\n        array: cloneAndSet(root.array, idx, n),\n      };\n    }\n    // otherwise the child node should be removed\n    // if it was the only child node, remove this node from the parent\n    if (root.bitmap === bit) {\n      return undefined;\n    }\n    // otherwise just remove the child node\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap ^ bit,\n      array: spliceOut(root.array, idx),\n    };\n  }\n  // otherwise the item is an entry, remove it if the key matches\n  if (isEqual(key, node.k)) {\n    if (root.bitmap === bit) {\n      return undefined;\n    }\n    return {\n      type: INDEX_NODE,\n      bitmap: root.bitmap ^ bit,\n      array: spliceOut(root.array, idx),\n    };\n  }\n  return root;\n}\n/**\n * @template K,V\n * @param {CollisionNode<K,V>} root\n * @param {K} key\n * @returns {undefined | Node<K,V>}\n */\nfunction withoutCollision(root, key) {\n  const idx = collisionIndexOf(root, key);\n  // if the key not found, no changes\n  if (idx < 0) {\n    return root;\n  }\n  // otherwise the entry was found, remove it\n  // if it was the only entry in this node, remove the whole node\n  if (root.array.length === 1) {\n    return undefined;\n  }\n  // otherwise just remove the entry\n  return {\n    type: COLLISION_NODE,\n    hash: root.hash,\n    array: spliceOut(root.array, idx),\n  };\n}\n/**\n * @template K,V\n * @param {undefined | Node<K,V>} root\n * @param {(value:V,key:K)=>void} fn\n * @returns {void}\n */\nfunction forEach(root, fn) {\n  if (root === undefined) {\n    return;\n  }\n  const items = root.array;\n  const size = items.length;\n  for (let i = 0; i < size; i++) {\n    const item = items[i];\n    if (item === undefined) {\n      continue;\n    }\n    if (item.type === ENTRY) {\n      fn(item.v, item.k);\n      continue;\n    }\n    forEach(item, fn);\n  }\n}\n/**\n * Extra wrapper to keep track of Dict size and clean up the API\n * @template K,V\n */\nexport default class Dict {\n  /**\n   * @template V\n   * @param {Record<string,V>} o\n   * @returns {Dict<string,V>}\n   */\n  static fromObject(o) {\n    const keys = Object.keys(o);\n    /** @type Dict<string,V> */\n    let m = Dict.new();\n    for (let i = 0; i < keys.length; i++) {\n      const k = keys[i];\n      m = m.set(k, o[k]);\n    }\n    return m;\n  }\n  /**\n   * @template K,V\n   * @param {Map<K,V>} o\n   * @returns {Dict<K,V>}\n   */\n  static fromMap(o) {\n    /** @type Dict<K,V> */\n    let m = Dict.new();\n    o.forEach((v, k) => {\n      m = m.set(k, v);\n    });\n    return m;\n  }\n  static new() {\n    return new Dict(undefined, 0);\n  }\n  /**\n   * @param {undefined | Node<K,V>} root\n   * @param {number} size\n   */\n  constructor(root, size) {\n    this.root = root;\n    this.size = size;\n  }\n  /**\n   * @template NotFound\n   * @param {K} key\n   * @param {NotFound} notFound\n   * @returns {NotFound | V}\n   */\n  get(key, notFound) {\n    if (this.root === undefined) {\n      return notFound;\n    }\n    const found = find(this.root, 0, getHash(key), key);\n    if (found === undefined) {\n      return notFound;\n    }\n    return found.v;\n  }\n  /**\n   * @param {K} key\n   * @param {V} val\n   * @returns {Dict<K,V>}\n   */\n  set(key, val) {\n    const addedLeaf = { val: false };\n    const root = this.root === undefined ? EMPTY : this.root;\n    const newRoot = assoc(root, 0, getHash(key), key, val, addedLeaf);\n    if (newRoot === this.root) {\n      return this;\n    }\n    return new Dict(newRoot, addedLeaf.val ? this.size + 1 : this.size);\n  }\n  /**\n   * @param {K} key\n   * @returns {Dict<K,V>}\n   */\n  delete(key) {\n    if (this.root === undefined) {\n      return this;\n    }\n    const newRoot = without(this.root, 0, getHash(key), key);\n    if (newRoot === this.root) {\n      return this;\n    }\n    if (newRoot === undefined) {\n      return Dict.new();\n    }\n    return new Dict(newRoot, this.size - 1);\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    if (this.root === undefined) {\n      return false;\n    }\n    return find(this.root, 0, getHash(key), key) !== undefined;\n  }\n  /**\n   * @returns {[K,V][]}\n   */\n  entries() {\n    if (this.root === undefined) {\n      return [];\n    }\n    /** @type [K,V][] */\n    const result = [];\n    this.forEach((v, k) => result.push([k, v]));\n    return result;\n  }\n  /**\n   *\n   * @param {(val:V,key:K)=>void} fn\n   */\n  forEach(fn) {\n    forEach(this.root, fn);\n  }\n  hashCode() {\n    let h = 0;\n    this.forEach((v, k) => {\n      h = (h + hashMerge(getHash(v), getHash(k))) | 0;\n    });\n    return h;\n  }\n  /**\n   * @param {unknown} o\n   * @returns {boolean}\n   */\n  equals(o) {\n    if (!(o instanceof Dict) || this.size !== o.size) {\n      return false;\n    }\n    let equal = true;\n    this.forEach((v, k) => {\n      equal = equal && isEqual(o.get(k, !v), v);\n    });\n    return equal;\n  }\n}\n", "import { Ok, Error, toList, CustomType as $CustomType, divideInt, isEqual } from \"../gleam.mjs\";\nimport * as $dict from \"../gleam/dict.mjs\";\nimport * as $float from \"../gleam/float.mjs\";\nimport * as $int from \"../gleam/int.mjs\";\nimport * as $order from \"../gleam/order.mjs\";\nimport * as $pair from \"../gleam/pair.mjs\";\n\nexport class LengthMismatch extends $CustomType {}\n\nexport class Continue extends $CustomType {\n  constructor(x0) {\n    super();\n    this[0] = x0;\n  }\n}\n\nexport class Stop extends $CustomType {\n  constructor(x0) {\n    super();\n    this[0] = x0;\n  }\n}\n\nfunction do_length_acc(loop$list, loop$count) {\n  while (true) {\n    let list = loop$list;\n    let count = loop$count;\n    if (list.atLeastLength(1)) {\n      let list$1 = list.tail;\n      loop$list = list$1;\n      loop$count = count + 1;\n    } else {\n      return count;\n    }\n  }\n}\n\nfunction do_length(list) {\n  return do_length_acc(list, 0);\n}\n\nexport function length(list) {\n  return do_length(list);\n}\n\nfunction do_reverse_acc(loop$remaining, loop$accumulator) {\n  while (true) {\n    let remaining = loop$remaining;\n    let accumulator = loop$accumulator;\n    if (remaining.hasLength(0)) {\n      return accumulator;\n    } else {\n      let item = remaining.head;\n      let rest$1 = remaining.tail;\n      loop$remaining = rest$1;\n      loop$accumulator = toList([item], accumulator);\n    }\n  }\n}\n\nfunction do_reverse(list) {\n  return do_reverse_acc(list, toList([]));\n}\n\nexport function reverse(xs) {\n  return do_reverse(xs);\n}\n\nexport function is_empty(list) {\n  return isEqual(list, toList([]));\n}\n\nexport function contains(loop$list, loop$elem) {\n  while (true) {\n    let list = loop$list;\n    let elem = loop$elem;\n    if (list.hasLength(0)) {\n      return false;\n    } else if (list.atLeastLength(1) && isEqual(list.head, elem)) {\n      let first$1 = list.head;\n      return true;\n    } else {\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$elem = elem;\n    }\n  }\n}\n\nexport function first(list) {\n  if (list.hasLength(0)) {\n    return new Error(undefined);\n  } else {\n    let x = list.head;\n    return new Ok(x);\n  }\n}\n\nexport function rest(list) {\n  if (list.hasLength(0)) {\n    return new Error(undefined);\n  } else {\n    let xs = list.tail;\n    return new Ok(xs);\n  }\n}\n\nfunction update_group(f) {\n  return (groups, elem) => {\n    let $ = $dict.get(groups, f(elem));\n    if ($.isOk()) {\n      let existing = $[0];\n      return $dict.insert(groups, f(elem), toList([elem], existing));\n    } else {\n      return $dict.insert(groups, f(elem), toList([elem]));\n    }\n  };\n}\n\nfunction do_filter(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let new_acc = (() => {\n        let $ = fun(x);\n        if ($) {\n          return toList([x], acc);\n        } else {\n          return acc;\n        }\n      })();\n      loop$list = xs;\n      loop$fun = fun;\n      loop$acc = new_acc;\n    }\n  }\n}\n\nexport function filter(list, predicate) {\n  return do_filter(list, predicate, toList([]));\n}\n\nfunction do_filter_map(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let new_acc = (() => {\n        let $ = fun(x);\n        if ($.isOk()) {\n          let x$1 = $[0];\n          return toList([x$1], acc);\n        } else {\n          return acc;\n        }\n      })();\n      loop$list = xs;\n      loop$fun = fun;\n      loop$acc = new_acc;\n    }\n  }\n}\n\nexport function filter_map(list, fun) {\n  return do_filter_map(list, fun, toList([]));\n}\n\nfunction do_map(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      loop$list = xs;\n      loop$fun = fun;\n      loop$acc = toList([fun(x)], acc);\n    }\n  }\n}\n\nexport function map(list, fun) {\n  return do_map(list, fun, toList([]));\n}\n\nfunction do_map2(loop$list1, loop$list2, loop$fun, loop$acc) {\n  while (true) {\n    let list1 = loop$list1;\n    let list2 = loop$list2;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list1.hasLength(0)) {\n      return reverse(acc);\n    } else if (list2.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let a = list1.head;\n      let as_ = list1.tail;\n      let b = list2.head;\n      let bs = list2.tail;\n      loop$list1 = as_;\n      loop$list2 = bs;\n      loop$fun = fun;\n      loop$acc = toList([fun(a, b)], acc);\n    }\n  }\n}\n\nexport function map2(list1, list2, fun) {\n  return do_map2(list1, list2, fun, toList([]));\n}\n\nfunction do_index_map(loop$list, loop$fun, loop$index, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let index = loop$index;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let acc$1 = toList([fun(x, index)], acc);\n      loop$list = xs;\n      loop$fun = fun;\n      loop$index = index + 1;\n      loop$acc = acc$1;\n    }\n  }\n}\n\nexport function index_map(list, fun) {\n  return do_index_map(list, fun, 0, toList([]));\n}\n\nfunction do_try_map(loop$list, loop$fun, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return new Ok(reverse(acc));\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let $ = fun(x);\n      if ($.isOk()) {\n        let y = $[0];\n        loop$list = xs;\n        loop$fun = fun;\n        loop$acc = toList([y], acc);\n      } else {\n        let error = $[0];\n        return new Error(error);\n      }\n    }\n  }\n}\n\nexport function try_map(list, fun) {\n  return do_try_map(list, fun, toList([]));\n}\n\nexport function drop(loop$list, loop$n) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let $ = n <= 0;\n    if ($) {\n      return list;\n    } else {\n      if (list.hasLength(0)) {\n        return toList([]);\n      } else {\n        let xs = list.tail;\n        loop$list = xs;\n        loop$n = n - 1;\n      }\n    }\n  }\n}\n\nfunction do_take(loop$list, loop$n, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let acc = loop$acc;\n    let $ = n <= 0;\n    if ($) {\n      return reverse(acc);\n    } else {\n      if (list.hasLength(0)) {\n        return reverse(acc);\n      } else {\n        let x = list.head;\n        let xs = list.tail;\n        loop$list = xs;\n        loop$n = n - 1;\n        loop$acc = toList([x], acc);\n      }\n    }\n  }\n}\n\nexport function take(list, n) {\n  return do_take(list, n, toList([]));\n}\n\nexport function new$() {\n  return toList([]);\n}\n\nfunction do_append_acc(loop$first, loop$second) {\n  while (true) {\n    let first = loop$first;\n    let second = loop$second;\n    if (first.hasLength(0)) {\n      return second;\n    } else {\n      let item = first.head;\n      let rest$1 = first.tail;\n      loop$first = rest$1;\n      loop$second = toList([item], second);\n    }\n  }\n}\n\nfunction do_append(first, second) {\n  return do_append_acc(reverse(first), second);\n}\n\nexport function append(first, second) {\n  return do_append(first, second);\n}\n\nexport function prepend(list, item) {\n  return toList([item], list);\n}\n\nfunction reverse_and_prepend(loop$prefix, loop$suffix) {\n  while (true) {\n    let prefix = loop$prefix;\n    let suffix = loop$suffix;\n    if (prefix.hasLength(0)) {\n      return suffix;\n    } else {\n      let first$1 = prefix.head;\n      let rest$1 = prefix.tail;\n      loop$prefix = rest$1;\n      loop$suffix = toList([first$1], suffix);\n    }\n  }\n}\n\nfunction do_concat(loop$lists, loop$acc) {\n  while (true) {\n    let lists = loop$lists;\n    let acc = loop$acc;\n    if (lists.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let list = lists.head;\n      let further_lists = lists.tail;\n      loop$lists = further_lists;\n      loop$acc = reverse_and_prepend(list, acc);\n    }\n  }\n}\n\nexport function concat(lists) {\n  return do_concat(lists, toList([]));\n}\n\nexport function flatten(lists) {\n  return do_concat(lists, toList([]));\n}\n\nexport function flat_map(list, fun) {\n  let _pipe = map(list, fun);\n  return concat(_pipe);\n}\n\nexport function fold(loop$list, loop$initial, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let initial = loop$initial;\n    let fun = loop$fun;\n    if (list.hasLength(0)) {\n      return initial;\n    } else {\n      let x = list.head;\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$initial = fun(initial, x);\n      loop$fun = fun;\n    }\n  }\n}\n\nexport function group(list, key) {\n  return fold(list, $dict.new$(), update_group(key));\n}\n\nexport function map_fold(list, acc, fun) {\n  let _pipe = fold(\n    list,\n    [acc, toList([])],\n    (acc, item) => {\n      let current_acc = acc[0];\n      let items = acc[1];\n      let $ = fun(current_acc, item);\n      let next_acc = $[0];\n      let next_item = $[1];\n      return [next_acc, toList([next_item], items)];\n    },\n  );\n  return $pair.map_second(_pipe, reverse);\n}\n\nexport function fold_right(list, initial, fun) {\n  if (list.hasLength(0)) {\n    return initial;\n  } else {\n    let x = list.head;\n    let rest$1 = list.tail;\n    return fun(fold_right(rest$1, initial, fun), x);\n  }\n}\n\nfunction do_index_fold(loop$over, loop$acc, loop$with, loop$index) {\n  while (true) {\n    let over = loop$over;\n    let acc = loop$acc;\n    let with$ = loop$with;\n    let index = loop$index;\n    if (over.hasLength(0)) {\n      return acc;\n    } else {\n      let first$1 = over.head;\n      let rest$1 = over.tail;\n      loop$over = rest$1;\n      loop$acc = with$(acc, first$1, index);\n      loop$with = with$;\n      loop$index = index + 1;\n    }\n  }\n}\n\nexport function index_fold(over, initial, fun) {\n  return do_index_fold(over, initial, fun, 0);\n}\n\nexport function try_fold(loop$collection, loop$accumulator, loop$fun) {\n  while (true) {\n    let collection = loop$collection;\n    let accumulator = loop$accumulator;\n    let fun = loop$fun;\n    if (collection.hasLength(0)) {\n      return new Ok(accumulator);\n    } else {\n      let first$1 = collection.head;\n      let rest$1 = collection.tail;\n      let $ = fun(accumulator, first$1);\n      if ($.isOk()) {\n        let result = $[0];\n        loop$collection = rest$1;\n        loop$accumulator = result;\n        loop$fun = fun;\n      } else {\n        let error = $;\n        return error;\n      }\n    }\n  }\n}\n\nexport function fold_until(loop$collection, loop$accumulator, loop$fun) {\n  while (true) {\n    let collection = loop$collection;\n    let accumulator = loop$accumulator;\n    let fun = loop$fun;\n    if (collection.hasLength(0)) {\n      return accumulator;\n    } else {\n      let first$1 = collection.head;\n      let rest$1 = collection.tail;\n      let $ = fun(accumulator, first$1);\n      if ($ instanceof Continue) {\n        let next_accumulator = $[0];\n        loop$collection = rest$1;\n        loop$accumulator = next_accumulator;\n        loop$fun = fun;\n      } else {\n        let b = $[0];\n        return b;\n      }\n    }\n  }\n}\n\nexport function find(loop$haystack, loop$is_desired) {\n  while (true) {\n    let haystack = loop$haystack;\n    let is_desired = loop$is_desired;\n    if (haystack.hasLength(0)) {\n      return new Error(undefined);\n    } else {\n      let x = haystack.head;\n      let rest$1 = haystack.tail;\n      let $ = is_desired(x);\n      if ($) {\n        return new Ok(x);\n      } else {\n        loop$haystack = rest$1;\n        loop$is_desired = is_desired;\n      }\n    }\n  }\n}\n\nexport function find_map(loop$haystack, loop$fun) {\n  while (true) {\n    let haystack = loop$haystack;\n    let fun = loop$fun;\n    if (haystack.hasLength(0)) {\n      return new Error(undefined);\n    } else {\n      let x = haystack.head;\n      let rest$1 = haystack.tail;\n      let $ = fun(x);\n      if ($.isOk()) {\n        let x$1 = $[0];\n        return new Ok(x$1);\n      } else {\n        loop$haystack = rest$1;\n        loop$fun = fun;\n      }\n    }\n  }\n}\n\nexport function all(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list.hasLength(0)) {\n      return true;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n      } else {\n        return false;\n      }\n    }\n  }\n}\n\nexport function any(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list.hasLength(0)) {\n      return false;\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        return true;\n      } else {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n      }\n    }\n  }\n}\n\nfunction do_zip(loop$xs, loop$ys, loop$acc) {\n  while (true) {\n    let xs = loop$xs;\n    let ys = loop$ys;\n    let acc = loop$acc;\n    if (xs.atLeastLength(1) && ys.atLeastLength(1)) {\n      let x = xs.head;\n      let xs$1 = xs.tail;\n      let y = ys.head;\n      let ys$1 = ys.tail;\n      loop$xs = xs$1;\n      loop$ys = ys$1;\n      loop$acc = toList([[x, y]], acc);\n    } else {\n      return reverse(acc);\n    }\n  }\n}\n\nexport function zip(list, other) {\n  return do_zip(list, other, toList([]));\n}\n\nexport function strict_zip(list, other) {\n  let $ = length(list) === length(other);\n  if ($) {\n    return new Ok(zip(list, other));\n  } else {\n    return new Error(new LengthMismatch());\n  }\n}\n\nfunction do_unzip(loop$input, loop$xs, loop$ys) {\n  while (true) {\n    let input = loop$input;\n    let xs = loop$xs;\n    let ys = loop$ys;\n    if (input.hasLength(0)) {\n      return [reverse(xs), reverse(ys)];\n    } else {\n      let x = input.head[0];\n      let y = input.head[1];\n      let rest$1 = input.tail;\n      loop$input = rest$1;\n      loop$xs = toList([x], xs);\n      loop$ys = toList([y], ys);\n    }\n  }\n}\n\nexport function unzip(input) {\n  return do_unzip(input, toList([]), toList([]));\n}\n\nfunction do_intersperse(loop$list, loop$separator, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let separator = loop$separator;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let x = list.head;\n      let rest$1 = list.tail;\n      loop$list = rest$1;\n      loop$separator = separator;\n      loop$acc = toList([x, separator], acc);\n    }\n  }\n}\n\nexport function intersperse(list, elem) {\n  if (list.hasLength(0)) {\n    return list;\n  } else if (list.hasLength(1)) {\n    return list;\n  } else {\n    let x = list.head;\n    let rest$1 = list.tail;\n    return do_intersperse(rest$1, elem, toList([x]));\n  }\n}\n\nexport function at(list, index) {\n  let $ = index >= 0;\n  if ($) {\n    let _pipe = list;\n    let _pipe$1 = drop(_pipe, index);\n    return first(_pipe$1);\n  } else {\n    return new Error(undefined);\n  }\n}\n\nexport function unique(list) {\n  if (list.hasLength(0)) {\n    return toList([]);\n  } else {\n    let x = list.head;\n    let rest$1 = list.tail;\n    return toList(\n      [x],\n      unique(filter(rest$1, (y) => { return !isEqual(y, x); })),\n    );\n  }\n}\n\nfunction merge_up(loop$na, loop$nb, loop$a, loop$b, loop$acc, loop$compare) {\n  while (true) {\n    let na = loop$na;\n    let nb = loop$nb;\n    let a = loop$a;\n    let b = loop$b;\n    let acc = loop$acc;\n    let compare = loop$compare;\n    if (na === 0 && nb === 0) {\n      return acc;\n    } else if (nb === 0 && a.atLeastLength(1)) {\n      let ax = a.head;\n      let ar = a.tail;\n      loop$na = na - 1;\n      loop$nb = nb;\n      loop$a = ar;\n      loop$b = b;\n      loop$acc = toList([ax], acc);\n      loop$compare = compare;\n    } else if (na === 0 && b.atLeastLength(1)) {\n      let bx = b.head;\n      let br = b.tail;\n      loop$na = na;\n      loop$nb = nb - 1;\n      loop$a = a;\n      loop$b = br;\n      loop$acc = toList([bx], acc);\n      loop$compare = compare;\n    } else if (a.atLeastLength(1) && b.atLeastLength(1)) {\n      let ax = a.head;\n      let ar = a.tail;\n      let bx = b.head;\n      let br = b.tail;\n      let $ = compare(ax, bx);\n      if ($ instanceof $order.Gt) {\n        loop$na = na;\n        loop$nb = nb - 1;\n        loop$a = a;\n        loop$b = br;\n        loop$acc = toList([bx], acc);\n        loop$compare = compare;\n      } else {\n        loop$na = na - 1;\n        loop$nb = nb;\n        loop$a = ar;\n        loop$b = b;\n        loop$acc = toList([ax], acc);\n        loop$compare = compare;\n      }\n    } else {\n      return acc;\n    }\n  }\n}\n\nfunction merge_down(loop$na, loop$nb, loop$a, loop$b, loop$acc, loop$compare) {\n  while (true) {\n    let na = loop$na;\n    let nb = loop$nb;\n    let a = loop$a;\n    let b = loop$b;\n    let acc = loop$acc;\n    let compare = loop$compare;\n    if (na === 0 && nb === 0) {\n      return acc;\n    } else if (nb === 0 && a.atLeastLength(1)) {\n      let ax = a.head;\n      let ar = a.tail;\n      loop$na = na - 1;\n      loop$nb = nb;\n      loop$a = ar;\n      loop$b = b;\n      loop$acc = toList([ax], acc);\n      loop$compare = compare;\n    } else if (na === 0 && b.atLeastLength(1)) {\n      let bx = b.head;\n      let br = b.tail;\n      loop$na = na;\n      loop$nb = nb - 1;\n      loop$a = a;\n      loop$b = br;\n      loop$acc = toList([bx], acc);\n      loop$compare = compare;\n    } else if (a.atLeastLength(1) && b.atLeastLength(1)) {\n      let ax = a.head;\n      let ar = a.tail;\n      let bx = b.head;\n      let br = b.tail;\n      let $ = compare(bx, ax);\n      if ($ instanceof $order.Lt) {\n        loop$na = na - 1;\n        loop$nb = nb;\n        loop$a = ar;\n        loop$b = b;\n        loop$acc = toList([ax], acc);\n        loop$compare = compare;\n      } else {\n        loop$na = na;\n        loop$nb = nb - 1;\n        loop$a = a;\n        loop$b = br;\n        loop$acc = toList([bx], acc);\n        loop$compare = compare;\n      }\n    } else {\n      return acc;\n    }\n  }\n}\n\nfunction merge_sort(l, ln, compare, down) {\n  let n = divideInt(ln, 2);\n  let a = l;\n  let b = drop(l, n);\n  let $ = ln < 3;\n  if ($) {\n    if (down) {\n      return merge_down(n, ln - n, a, b, toList([]), compare);\n    } else {\n      return merge_up(n, ln - n, a, b, toList([]), compare);\n    }\n  } else {\n    if (down) {\n      return merge_down(\n        n,\n        ln - n,\n        merge_sort(a, n, compare, false),\n        merge_sort(b, ln - n, compare, false),\n        toList([]),\n        compare,\n      );\n    } else {\n      return merge_up(\n        n,\n        ln - n,\n        merge_sort(a, n, compare, true),\n        merge_sort(b, ln - n, compare, true),\n        toList([]),\n        compare,\n      );\n    }\n  }\n}\n\nexport function sort(list, compare) {\n  return merge_sort(list, length(list), compare, true);\n}\n\nfunction tail_recursive_range(loop$start, loop$stop, loop$acc) {\n  while (true) {\n    let start = loop$start;\n    let stop = loop$stop;\n    let acc = loop$acc;\n    let $ = $int.compare(start, stop);\n    if ($ instanceof $order.Eq) {\n      return toList([stop], acc);\n    } else if ($ instanceof $order.Gt) {\n      loop$start = start;\n      loop$stop = stop + 1;\n      loop$acc = toList([stop], acc);\n    } else {\n      loop$start = start;\n      loop$stop = stop - 1;\n      loop$acc = toList([stop], acc);\n    }\n  }\n}\n\nexport function range(start, stop) {\n  return tail_recursive_range(start, stop, toList([]));\n}\n\nfunction do_repeat(loop$a, loop$times, loop$acc) {\n  while (true) {\n    let a = loop$a;\n    let times = loop$times;\n    let acc = loop$acc;\n    let $ = times <= 0;\n    if ($) {\n      return acc;\n    } else {\n      loop$a = a;\n      loop$times = times - 1;\n      loop$acc = toList([a], acc);\n    }\n  }\n}\n\nexport function repeat(a, times) {\n  return do_repeat(a, times, toList([]));\n}\n\nfunction do_split(loop$list, loop$n, loop$taken) {\n  while (true) {\n    let list = loop$list;\n    let n = loop$n;\n    let taken = loop$taken;\n    let $ = n <= 0;\n    if ($) {\n      return [reverse(taken), list];\n    } else {\n      if (list.hasLength(0)) {\n        return [reverse(taken), toList([])];\n      } else {\n        let x = list.head;\n        let xs = list.tail;\n        loop$list = xs;\n        loop$n = n - 1;\n        loop$taken = toList([x], taken);\n      }\n    }\n  }\n}\n\nexport function split(list, index) {\n  return do_split(list, index, toList([]));\n}\n\nfunction do_split_while(loop$list, loop$f, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return [reverse(acc), toList([])];\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let $ = f(x);\n      if (!$) {\n        return [reverse(acc), list];\n      } else {\n        loop$list = xs;\n        loop$f = f;\n        loop$acc = toList([x], acc);\n      }\n    }\n  }\n}\n\nexport function split_while(list, predicate) {\n  return do_split_while(list, predicate, toList([]));\n}\n\nexport function key_find(keyword_list, desired_key) {\n  return find_map(\n    keyword_list,\n    (keyword) => {\n      let key = keyword[0];\n      let value = keyword[1];\n      let $ = isEqual(key, desired_key);\n      if ($) {\n        return new Ok(value);\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\nexport function key_filter(keyword_list, desired_key) {\n  return filter_map(\n    keyword_list,\n    (keyword) => {\n      let key = keyword[0];\n      let value = keyword[1];\n      let $ = isEqual(key, desired_key);\n      if ($) {\n        return new Ok(value);\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\nfunction do_pop(loop$haystack, loop$predicate, loop$checked) {\n  while (true) {\n    let haystack = loop$haystack;\n    let predicate = loop$predicate;\n    let checked = loop$checked;\n    if (haystack.hasLength(0)) {\n      return new Error(undefined);\n    } else {\n      let x = haystack.head;\n      let rest$1 = haystack.tail;\n      let $ = predicate(x);\n      if ($) {\n        return new Ok([x, append(reverse(checked), rest$1)]);\n      } else {\n        loop$haystack = rest$1;\n        loop$predicate = predicate;\n        loop$checked = toList([x], checked);\n      }\n    }\n  }\n}\n\nexport function pop(haystack, is_desired) {\n  return do_pop(haystack, is_desired, toList([]));\n}\n\nfunction do_pop_map(loop$haystack, loop$mapper, loop$checked) {\n  while (true) {\n    let haystack = loop$haystack;\n    let mapper = loop$mapper;\n    let checked = loop$checked;\n    if (haystack.hasLength(0)) {\n      return new Error(undefined);\n    } else {\n      let x = haystack.head;\n      let rest$1 = haystack.tail;\n      let $ = mapper(x);\n      if ($.isOk()) {\n        let y = $[0];\n        return new Ok([y, append(reverse(checked), rest$1)]);\n      } else {\n        loop$haystack = rest$1;\n        loop$mapper = mapper;\n        loop$checked = toList([x], checked);\n      }\n    }\n  }\n}\n\nexport function pop_map(haystack, is_desired) {\n  return do_pop_map(haystack, is_desired, toList([]));\n}\n\nexport function key_pop(haystack, key) {\n  return pop_map(\n    haystack,\n    (entry) => {\n      let k = entry[0];\n      let v = entry[1];\n      if (isEqual(k, key)) {\n        let k$1 = k;\n        return new Ok(v);\n      } else {\n        return new Error(undefined);\n      }\n    },\n  );\n}\n\nexport function key_set(list, key, value) {\n  if (list.hasLength(0)) {\n    return toList([[key, value]]);\n  } else if (list.atLeastLength(1) && isEqual(list.head[0], key)) {\n    let k = list.head[0];\n    let rest$1 = list.tail;\n    return toList([[key, value]], rest$1);\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return toList([first$1], key_set(rest$1, key, value));\n  }\n}\n\nexport function each(loop$list, loop$f) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    if (list.hasLength(0)) {\n      return undefined;\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      f(x);\n      loop$list = xs;\n      loop$f = f;\n    }\n  }\n}\n\nexport function try_each(loop$list, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let fun = loop$fun;\n    if (list.hasLength(0)) {\n      return new Ok(undefined);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let $ = fun(x);\n      if ($.isOk()) {\n        loop$list = xs;\n        loop$fun = fun;\n      } else {\n        let e = $[0];\n        return new Error(e);\n      }\n    }\n  }\n}\n\nfunction do_partition(loop$list, loop$categorise, loop$trues, loop$falses) {\n  while (true) {\n    let list = loop$list;\n    let categorise = loop$categorise;\n    let trues = loop$trues;\n    let falses = loop$falses;\n    if (list.hasLength(0)) {\n      return [reverse(trues), reverse(falses)];\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let $ = categorise(x);\n      if ($) {\n        loop$list = xs;\n        loop$categorise = categorise;\n        loop$trues = toList([x], trues);\n        loop$falses = falses;\n      } else {\n        loop$list = xs;\n        loop$categorise = categorise;\n        loop$trues = trues;\n        loop$falses = toList([x], falses);\n      }\n    }\n  }\n}\n\nexport function partition(list, categorise) {\n  return do_partition(list, categorise, toList([]), toList([]));\n}\n\nexport function permutations(l) {\n  if (l.hasLength(0)) {\n    return toList([toList([])]);\n  } else {\n    let _pipe = l;\n    let _pipe$1 = index_map(\n      _pipe,\n      (i, i_idx) => {\n        let _pipe$1 = l;\n        let _pipe$2 = index_fold(\n          _pipe$1,\n          toList([]),\n          (acc, j, j_idx) => {\n            let $ = i_idx === j_idx;\n            if ($) {\n              return acc;\n            } else {\n              return toList([j], acc);\n            }\n          },\n        );\n        let _pipe$3 = reverse(_pipe$2);\n        let _pipe$4 = permutations(_pipe$3);\n        return map(\n          _pipe$4,\n          (permutation) => { return toList([i], permutation); },\n        );\n      },\n    );\n    return concat(_pipe$1);\n  }\n}\n\nfunction do_window(loop$acc, loop$l, loop$n) {\n  while (true) {\n    let acc = loop$acc;\n    let l = loop$l;\n    let n = loop$n;\n    let window$1 = take(l, n);\n    let $ = length(window$1) === n;\n    if ($) {\n      loop$acc = toList([window$1], acc);\n      loop$l = drop(l, 1);\n      loop$n = n;\n    } else {\n      return acc;\n    }\n  }\n}\n\nexport function window(l, n) {\n  let _pipe = do_window(toList([]), l, n);\n  return reverse(_pipe);\n}\n\nexport function window_by_2(l) {\n  return zip(l, drop(l, 1));\n}\n\nexport function drop_while(loop$list, loop$predicate) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    if (list.hasLength(0)) {\n      return toList([]);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let $ = predicate(x);\n      if ($) {\n        loop$list = xs;\n        loop$predicate = predicate;\n      } else {\n        return toList([x], xs);\n      }\n    }\n  }\n}\n\nfunction do_take_while(loop$list, loop$predicate, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let predicate = loop$predicate;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return reverse(acc);\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let $ = predicate(first$1);\n      if ($) {\n        loop$list = rest$1;\n        loop$predicate = predicate;\n        loop$acc = toList([first$1], acc);\n      } else {\n        return reverse(acc);\n      }\n    }\n  }\n}\n\nexport function take_while(list, predicate) {\n  return do_take_while(list, predicate, toList([]));\n}\n\nfunction do_chunk(\n  loop$list,\n  loop$f,\n  loop$previous_key,\n  loop$current_chunk,\n  loop$acc\n) {\n  while (true) {\n    let list = loop$list;\n    let f = loop$f;\n    let previous_key = loop$previous_key;\n    let current_chunk = loop$current_chunk;\n    let acc = loop$acc;\n    if (list.atLeastLength(1)) {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let key = f(first$1);\n      let $ = isEqual(key, previous_key);\n      if (!$) {\n        let new_acc = toList([reverse(current_chunk)], acc);\n        loop$list = rest$1;\n        loop$f = f;\n        loop$previous_key = key;\n        loop$current_chunk = toList([first$1]);\n        loop$acc = new_acc;\n      } else {\n        loop$list = rest$1;\n        loop$f = f;\n        loop$previous_key = key;\n        loop$current_chunk = toList([first$1], current_chunk);\n        loop$acc = acc;\n      }\n    } else {\n      return reverse(toList([reverse(current_chunk)], acc));\n    }\n  }\n}\n\nexport function chunk(list, f) {\n  if (list.hasLength(0)) {\n    return toList([]);\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return do_chunk(rest$1, f, f(first$1), toList([first$1]), toList([]));\n  }\n}\n\nfunction do_sized_chunk(\n  loop$list,\n  loop$count,\n  loop$left,\n  loop$current_chunk,\n  loop$acc\n) {\n  while (true) {\n    let list = loop$list;\n    let count = loop$count;\n    let left = loop$left;\n    let current_chunk = loop$current_chunk;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      if (current_chunk.hasLength(0)) {\n        return reverse(acc);\n      } else {\n        let remaining = current_chunk;\n        return reverse(toList([reverse(remaining)], acc));\n      }\n    } else {\n      let first$1 = list.head;\n      let rest$1 = list.tail;\n      let chunk$1 = toList([first$1], current_chunk);\n      let $ = left > 1;\n      if (!$) {\n        loop$list = rest$1;\n        loop$count = count;\n        loop$left = count;\n        loop$current_chunk = toList([]);\n        loop$acc = toList([reverse(chunk$1)], acc);\n      } else {\n        loop$list = rest$1;\n        loop$count = count;\n        loop$left = left - 1;\n        loop$current_chunk = chunk$1;\n        loop$acc = acc;\n      }\n    }\n  }\n}\n\nexport function sized_chunk(list, count) {\n  return do_sized_chunk(list, count, count, toList([]), toList([]));\n}\n\nexport function reduce(list, fun) {\n  if (list.hasLength(0)) {\n    return new Error(undefined);\n  } else {\n    let first$1 = list.head;\n    let rest$1 = list.tail;\n    return new Ok(fold(rest$1, first$1, fun));\n  }\n}\n\nfunction do_scan(loop$list, loop$accumulator, loop$accumulated, loop$fun) {\n  while (true) {\n    let list = loop$list;\n    let accumulator = loop$accumulator;\n    let accumulated = loop$accumulated;\n    let fun = loop$fun;\n    if (list.hasLength(0)) {\n      return reverse(accumulated);\n    } else {\n      let x = list.head;\n      let xs = list.tail;\n      let next = fun(accumulator, x);\n      loop$list = xs;\n      loop$accumulator = next;\n      loop$accumulated = toList([next], accumulated);\n      loop$fun = fun;\n    }\n  }\n}\n\nexport function scan(list, initial, fun) {\n  return do_scan(list, initial, toList([]), fun);\n}\n\nexport function last(list) {\n  let _pipe = list;\n  return reduce(_pipe, (_, elem) => { return elem; });\n}\n\nexport function combinations(items, n) {\n  if (n === 0) {\n    return toList([toList([])]);\n  } else {\n    if (items.hasLength(0)) {\n      return toList([]);\n    } else {\n      let x = items.head;\n      let xs = items.tail;\n      let first_combinations = (() => {\n        let _pipe = map(\n          combinations(xs, n - 1),\n          (com) => { return toList([x], com); },\n        );\n        return reverse(_pipe);\n      })();\n      return fold(\n        first_combinations,\n        combinations(xs, n),\n        (acc, c) => { return toList([c], acc); },\n      );\n    }\n  }\n}\n\nfunction do_combination_pairs(items) {\n  if (items.hasLength(0)) {\n    return toList([]);\n  } else {\n    let x = items.head;\n    let xs = items.tail;\n    let first_combinations = map(xs, (other) => { return [x, other]; });\n    return toList([first_combinations], do_combination_pairs(xs));\n  }\n}\n\nexport function combination_pairs(items) {\n  let _pipe = do_combination_pairs(items);\n  return concat(_pipe);\n}\n\nexport function transpose(loop$list_of_list) {\n  while (true) {\n    let list_of_list = loop$list_of_list;\n    let take_first = (list) => {\n      if (list.hasLength(0)) {\n        return toList([]);\n      } else if (list.hasLength(1)) {\n        let f = list.head;\n        return toList([f]);\n      } else {\n        let f = list.head;\n        return toList([f]);\n      }\n    };\n    if (list_of_list.hasLength(0)) {\n      return toList([]);\n    } else if (list_of_list.atLeastLength(1) && list_of_list.head.hasLength(0)) {\n      let xss = list_of_list.tail;\n      loop$list_of_list = xss;\n    } else {\n      let rows = list_of_list;\n      let firsts = (() => {\n        let _pipe = rows;\n        let _pipe$1 = map(_pipe, take_first);\n        return concat(_pipe$1);\n      })();\n      let rest$1 = transpose(\n        map(rows, (_capture) => { return drop(_capture, 1); }),\n      );\n      return toList([firsts], rest$1);\n    }\n  }\n}\n\nexport function interleave(list) {\n  let _pipe = transpose(list);\n  return concat(_pipe);\n}\n\nfunction do_shuffle_pair_unwrap(loop$list, loop$acc) {\n  while (true) {\n    let list = loop$list;\n    let acc = loop$acc;\n    if (list.hasLength(0)) {\n      return acc;\n    } else {\n      let elem_pair = list.head;\n      let enumerable = list.tail;\n      loop$list = enumerable;\n      loop$acc = toList([elem_pair[1]], acc);\n    }\n  }\n}\n\nfunction do_shuffle_by_pair_indexes(list_of_pairs) {\n  return sort(\n    list_of_pairs,\n    (a_pair, b_pair) => { return $float.compare(a_pair[0], b_pair[0]); },\n  );\n}\n\nexport function shuffle(list) {\n  let _pipe = list;\n  let _pipe$1 = fold(\n    _pipe,\n    toList([]),\n    (acc, a) => { return toList([[$float.random(), a]], acc); },\n  );\n  let _pipe$2 = do_shuffle_by_pair_indexes(_pipe$1);\n  return do_shuffle_pair_unwrap(_pipe$2, toList([]));\n}\n", "import * as $list from \"../gleam_stdlib/gleam/list.mjs\";\nimport * as $result from \"../gleam_stdlib/gleam/result.mjs\";\nimport { Ok, Error, toList, CustomType as $CustomType, makeError } from \"./gleam.mjs\";\n\nclass Continue extends $CustomType {\n  constructor(effect) {\n    super();\n    this.effect = effect;\n  }\n}\n\nclass Stop extends $CustomType {\n  constructor(err) {\n    super();\n    this.err = err;\n  }\n}\n\nexport function delay_effect(f) {\n  return new Continue(f);\n}\n\nfunction chain(delayed_f, f) {\n  return () => {\n    let $ = delayed_f();\n    if ($.isOk()) {\n      let value = $[0];\n      return f(value);\n    } else {\n      let err = $[0];\n      return new Error(err);\n    }\n  };\n}\n\nexport function map(delayed, f) {\n  if (delayed instanceof Continue) {\n    let delayed_f = delayed.effect;\n    let _pipe = chain(delayed_f, f);\n    return delay_effect(_pipe);\n  } else {\n    let err = delayed.err;\n    return new Stop(err);\n  }\n}\n\nexport function flatten(delayed) {\n  let _pipe = (() => {\n    if (delayed instanceof Continue) {\n      let delayed_f = delayed.effect;\n      return () => {\n        let inner = (() => {\n          let $ = delayed_f();\n          if ($.isOk()) {\n            let inner_delay = $[0];\n            return inner_delay;\n          } else {\n            let err = $[0];\n            return new Stop(err);\n          }\n        })();\n        if (inner instanceof Continue) {\n          let inner_f = inner.effect;\n          return inner_f();\n        } else {\n          let err = inner.err;\n          return new Error(err);\n        }\n      };\n    } else {\n      let err = delayed.err;\n      return () => { return new Error(err); };\n    }\n  })();\n  return delay_effect(_pipe);\n}\n\nexport function flat_map(delayed, f) {\n  let _pipe = delayed;\n  let _pipe$1 = map(_pipe, f);\n  return flatten(_pipe$1);\n}\n\nfunction sleep(_) {\n  return undefined;\n}\n\nexport function run(delayed) {\n  if (delayed instanceof Continue) {\n    let f = delayed.effect;\n    return f();\n  } else {\n    let err = delayed.err;\n    return new Error(err);\n  }\n}\n\nfunction do_retry(loop$delayed, loop$retries, loop$delay, loop$backoff) {\n  while (true) {\n    let delayed = loop$delayed;\n    let retries = loop$retries;\n    let delay = loop$delay;\n    let backoff = loop$backoff;\n    let delay$1 = (() => {\n      if (backoff) {\n        return delay + 1000;\n      } else {\n        return delay;\n      }\n    })();\n    if (retries <= 1) {\n      let n = retries;\n      return run(delayed);\n    } else {\n      let $ = run(delayed);\n      if ($.isOk()) {\n        let res = $[0];\n        return new Ok(res);\n      } else {\n        sleep(delay$1);\n        loop$delayed = delayed;\n        loop$retries = retries - 1;\n        loop$delay = delay$1;\n        loop$backoff = backoff;\n      }\n    }\n  }\n}\n\nexport function retry(delayed, retries, delay) {\n  return delay_effect(\n    () => { return do_retry(delayed, retries, delay, false); },\n  );\n}\n\nexport function retry_with_backoff(delayed, retries) {\n  return delay_effect(() => { return do_retry(delayed, retries, 0, true); });\n}\n\nexport function drain(delayed) {\n  let $ = run(delayed);\n  \n  return undefined;\n}\n\nfunction do_every(loop$effects, loop$results) {\n  while (true) {\n    let effects = loop$effects;\n    let results = loop$results;\n    if (effects.hasLength(1)) {\n      let last = effects.head;\n      return toList([run(last)], results);\n    } else if (effects.atLeastLength(1)) {\n      let head = effects.head;\n      let rest = effects.tail;\n      loop$effects = rest;\n      loop$results = toList([run(head)], results);\n    } else {\n      throw makeError(\"todo\", \"delay\", 185, \"do_every\", \"Empty list\", {})\n    }\n  }\n}\n\nexport function every(effects) {\n  return do_every(effects, toList([]));\n}\n\nexport function repeat(delayed, repetition) {\n  let _pipe = delayed;\n  let _pipe$1 = $list.repeat(_pipe, repetition);\n  return every(_pipe$1);\n}\n\nexport function all(effects) {\n  let _pipe = effects;\n  let _pipe$1 = every(_pipe);\n  let _pipe$2 = $result.all(_pipe$1);\n  return $result.is_ok(_pipe$2);\n}\n\nexport function any(effects) {\n  return (() => {\n    let _pipe = effects;\n    let _pipe$1 = every(_pipe);\n    let _pipe$2 = $list.filter(_pipe$1, $result.is_ok);\n    return $list.length(_pipe$2);\n  })() > 0;\n}\n\nfunction do_fallthrough(effects) {\n  if (effects.hasLength(1)) {\n    let last = effects.head;\n    return run(last);\n  } else if (effects.atLeastLength(1)) {\n    let head = effects.head;\n    let rest = effects.tail;\n    let $ = run(head);\n    if ($.isOk()) {\n      let res = $[0];\n      return new Ok(res);\n    } else {\n      return fallthrough(rest);\n    }\n  } else {\n    throw makeError(\"todo\", \"delay\", 204, \"do_fallthrough\", \"Empty list\", {})\n  }\n}\n\nexport function fallthrough(effects) {\n  return do_fallthrough(effects);\n}\n"],
  "mappings": "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",
  "names": ["length", "Error", "length", "Error", "Error", "map", "repeat", "all", "length"]
}
